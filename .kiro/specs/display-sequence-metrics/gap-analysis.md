# ギャップ分析: display-sequence-metrics

**作成日:** 2025-11-22
**言語:** 日本語

## 分析サマリ（要約・推奨、3–5 点）

- 要求は「ルーム作成時に `sequenceType` が `fibonacci` または `natural` の場合、投票公開時に `"?"` を除外して中央値と平均を算出し既存の公開トーストに表示する」という点である。既存コードはサーバー側で計算し、`votesRevealed` に `metrics` を追加して配信する実装がなされている。
- 実装は主要要件（`?` 除外、中央値/平均算出、サーバー側計算、クライアントでのトースト表示）を満たしている。表示持続仕様については、ユーザーの指示に基づき「永続（次のトーストが来るまで表示）」としてドキュメントに反映済みであり、現在は実装とドキュメントが一致している。テストおよび性能検証（200ms 要件）は現時点ではユーザー指示により保留となっている。
- 迅速かつ安全な拡張方針としては現状の最小変更アプローチ（`server.js` と `public/app.js` の拡張）で良いが、保守性とテスト容易性のために計算ロジックを専用モジュールに切り出す（将来的に `lib/sequence-metrics.js` を追加）ことを推奨する。

## ドキュメントステータス

- 読み込んだファイル:

  - `.kiro/specs/display-sequence-metrics/spec.json`（言語: ja, フェーズ: tasks-generated）
  - `.kiro/specs/display-sequence-metrics/requirements.md`（EARS 形式で要件記載）
  - `.kiro/steering/structure.md`, `.kiro/steering/tech.md`（アーキテクチャ方針、設計制約）
  - `.kiro/settings/rules/gap-analysis.md`（分析フレームワーク）
  - `server.js`, `public/app.js`（実装コード）

- 分析アプローチ: 上記ファイルを読み、requirement→ 実装アセットマッピングを行い、未解決点（テスト・性能・表示仕様差分）を抽出しました。

## 要件 → アセット マップ（ギャップと判断）

- 要件: 「`sequenceType` が `fibonacci`/`natural` の場合にのみ計算」

  - 実装: `server.js` の `handleRevealVotes` で `room.sequence` を参照し、条件分岐を実装済み。
  - ギャップ: なし（要件を満たしている）。

- 要件: `"?"` を除外して中央値・平均を算出し、除外件数を表示

  - 実装: `handleRevealVotes` 内で `v === "?"` を除外し、`excludedCount` を集計。`metrics` に `median`, `mean`, `excludedCount` をセットし、`votesRevealed` に含めてブロードキャストしている。クライアント側も `data.metrics` を受け取り表示している。
  - ギャップ: なし（機能的には実装済み）。ただし小数点処理や四捨五入ルールが仕様で明確化されていないため表示精度に関する合意が必要。

- 要件: 既存の「投票が公開されました！」カード内で中央値・平均を表示し、10 秒間表示する

  - 実装: 当初の実装では `public/app.js` が 10000ms を渡して 10 秒表示していたが、ユーザーの最終指示により `public/app.js` を永続表示（`showStatus(..., null)`）へ変更し、`requirements.md` もそれに合わせて更新済みである。
  - ギャップ: 表示持続に関するギャップは解消され、実装とドキュメントは一致している。テストおよび性能検証（200ms 要件）はユーザー指示により保留中である。

- 要件: パフォーマンス目標（計算と表示を 200ms 以下）

  - 実装: サーバー側同期処理で `numericValues.sort()` による中央値算出（O(n log n)）を行っている。小〜中規模（数十〜数百）では十分高速だが、要件の「200ms」を保証するためには実際の計測が必要。
  - ギャップ: 実測データが無く、パフォーマンス保証は未確認。大規模（users 数千など）ではアルゴリズム改善や非同期処理が必要になる可能性あり。

- 要件: 受け入れ基準（中央値・平均が手計算値と一致）
  - 実装: ロジックは基本的に一致するはずだが、単体テスト／自動化テストが存在しないため検証が手作業に依存している。
  - ギャップ: テスト不足（ユニットテスト、統合テストが未実施）。

## リスクと未解決事項（Research Needed）

- 仕様の優先順位: 「10 秒表示」か「次のトーストまで表示する（永続）」か、要求ドキュメントを更新して事実を一致させる必要あり。
- 表示精度ルール: 平均・中央値の小数点表示（丸め、桁数）が要件に無い。UI と受け入れ基準で決める必要あり。
- パフォーマンス実測: 200ms の SLA を満たすかを確認するベンチマークが必要。大規模ユーザー数を想定するならアルゴリズム見直しまたは非同期化が必要。
- エッジケース: 全投票が `"?"` の場合、現在は `median: null` / `mean: null` を返す。クライアント表示（N/A 表示等）と受け入れ基準の整合が必要。
- テスト戦略: WebSocket を使った統合テスト（ヘッドレス ws クライアント）、および `metrics` 計算ロジックのユニットテストが未実装。

## 実装アプローチの選択肢（Options A/B/C）

### Option A — 既存コンポーネントを拡張（現状）

- 何をするか: `server.js` の `handleRevealVotes` に計算ロジックを置き、`public/app.js` に表示ロジックを置く（現在の実装）。
- 利点: 変更点が少なく早くデプロイ可能。既存のプロトコルを利用するため互換性が高い。
- 欠点: `server.js` が成長し責務が増えると保守性が低下。テストが書きにくい。
- 努力/リスク: Effort = S（1–3 日）、Risk = Low

### Option B — 新規コンポーネント（SequenceMetricsService）を作成

- 何をするか: `lib/sequence-metrics.js` のようなモジュールを追加し、中央値/平均計算・除外ルールを切り出す。`server.js` からはそのモジュールを呼び出すだけにする。
- 利点: 計算ロジックが単体テスト可能になり保守性が向上。将来的なアルゴリズム差し替え（O(n) median など）や監査が容易。
- 欠点: ファイル数が増えるが設計上は望ましい。
- 努力/リスク: Effort = M（3–7 日）※テスト作成含む、Risk = Medium

### Option C — ハイブリッド（段階的抽出）

- 何をするか: まず現状の拡張（Option A）でデプロイ可能な最小実装を行い、その後計算ロジックを段階的に `lib/` に抽出してテスト追加・性能改善を図る。
- 利点: 早期リリースと長期的な保守性改善のバランスを取れる。
- 欠点: 途中で整合性を保つための小さなリファクタが必要。
- 努力/リスク: Effort = M（設計 → 抽出 → テスト工程を含む）、Risk = Medium

## 推奨（設計フェーズへの提案）

- 優先アプローチ: Option C（ハイブリッド）を推奨。理由: 既に動作している最小実装があるため早期価値提供が可能で、同時に計算ロジックを切り出してテストを追加すれば品質と保守性を確保できるため。
- 具体的決定事項（設計フェーズで確定）:
  1. 表示持続仕様は `requirements.md` に「永続（次のトーストが来るまで）」として反映済み。
  2. 平均・中央値の表示ルール（小数点桁数、丸め規則、N/A 表示）を明文化すること。
  3. 新規 `lib/sequence-metrics.js` を作ってユニットテストを整備する（これは保留指定可能）。
  4. 性能目標（200ms）を検証するためのベンチマーク計画を作るが、現時点では性能計測はユーザー指示により保留されている。

## 実装コスト見積りとリスク総括

- 最小実装（Option A、QA・テスト除く）: Effort = S（1–3 日）、Risk = Low
- きちんとした実装（モジュール分割 + 単体/統合テスト + ベンチ）: Effort = M（3–7 日）、Risk = Medium
- 大規模改修（大規模ルームの最適化、外部ストレージや pub/sub 連携）: Effort = L–XL、Risk = Medium–High

## 推奨される次の作業（設計フェーズへのインプット）

1. `requirements.md` を更新して「表示持続（10 秒 or 永続）」の最終仕様を確定する。
2. `lib/sequence-metrics.js` を設計してユニットテスト（Node + Jest や Mocha）を追加する。
3. ベンチマークを作成して 200ms 要件を確認する（負荷に応じてアルゴリズム改善を検討）。
4. 受け入れテストケースを作成：典型ケース、全 `"?"`、混在ケース、奇数/偶数要素での中央値チェック。

---

以上。ギャップ分析文書を保存しました。次に設計を作成しますか（`/kiro-spec-design display-sequence-metrics`）、または自動で設計を生成しますか（`/kiro-spec-design display-sequence-metrics -y`）？
